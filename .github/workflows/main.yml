name: Move Data from Account_Raw to Omega

on:
  schedule:
    - cron: "*/2 * * * *"   # every 2 minutes
  workflow_dispatch:

jobs:
  run-sql:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install node deps
        run: npm install jsonwebtoken node-fetch@2

      - name: Decode private key
        run: |
          echo "${{ secrets.SNOW_PRIVATE_KEY_BASE64 }}" | base64 --decode > ./rsa_key.p8
          chmod 600 ./rsa_key.p8

      - name: Read SQL file (move_data)
        run: |
          # Ensure path is exactly sql/move_data.sql (case-sensitive)
          if [ ! -f sql/move_data.sql ]; then
            echo "ERROR: sql/move_data.sql not found in repo"
            ls -la
            exit 2
          fi
          SQL_CONTENT="$(tr '\n' ' ' < sql/move_data.sql)"
          echo "$SQL_CONTENT" > sql_encoded.txt

      - name: Generate JWT and call Snowflake SQL API
        env:
          SNOW_ACCOUNT: ${{ secrets.SNOW_ACCOUNT }}
          SNOW_USER: ${{ secrets.SNOW_USER }}
          SNOW_DATABASE: ${{ secrets.SNOW_DATABASE }}
          SNOW_SCHEMA: ${{ secrets.SNOW_SCHEMA }}
          SNOW_WAREHOUSE: ${{ secrets.SNOW_WAREHOUSE }}
          SNOW_PUBKEY_FP: ${{ secrets.SNOW_PUBKEY_FP }}
          SNOWFLAKE_PUBKEY_FP: ${{ secrets.SNOWFLAKE_PUBKEY_FP }}
        run: |
          node <<'EOF'
          const fs = require('fs');
          const jwt = require('jsonwebtoken');
          const fetch = require('node-fetch');

          // read env (allow either SNOW_PUBKEY_FP or SNOWFLAKE_PUBKEY_FP)
          let account = (process.env.SNOW_ACCOUNT || '').toString().trim().toUpperCase();
          let user = (process.env.SNOW_USER || '').toString().trim().toUpperCase();
          let pubFp = (process.env.SNOW_PUBKEY_FP || '').toString().trim();
          if (!pubFp) pubFp = (process.env.SNOWFLAKE_PUBKEY_FP || '').toString().trim();

          if (!account || !user || !pubFp) {
            console.error('Missing required env: SNOW_ACCOUNT, SNOW_USER or public key fingerprint (SNOW_PUBKEY_FP or SNOWFLAKE_PUBKEY_FP).');
            console.error('SNOW_ACCOUNT:', !!process.env.SNOW_ACCOUNT);
            console.error('SNOW_USER:', !!process.env.SNOW_USER);
            console.error('SNOW_PUBKEY_FP present:', !!process.env.SNOW_PUBKEY_FP);
            console.error('SNOWFLAKE_PUBKEY_FP present:', !!process.env.SNOWFLAKE_PUBKEY_FP);
            process.exit(10);
          }

          // Remove region part from account if present (everything after first dot)
          if (account.indexOf('.') !== -1) {
            account = account.split('.')[0];
          }

          // Build qualified username and issuer per Snowflake docs
          const qualified = `${account}.${user}`;                // SUB
          const iss = `${qualified}.${pubFp}`;                  // ISS (includes SHA256:... fingerprint)

          const now = Math.floor(Date.now() / 1000);
          const payload = {
            iss: iss,
            sub: qualified,
            iat: now,
            exp: now + 60,
            aud: `https://${account}.snowflakecomputing.com`
          };

          // Read private key (decoded earlier)
          const key = fs.readFileSync('./rsa_key.p8', 'utf8');

          // Sign JWT using RS256
          let token;
          try {
            token = jwt.sign(payload, key, { algorithm: 'RS256' });
          } catch (err) {
            console.error('JWT sign error:', err && err.message ? err.message : err);
            process.exit(11);
          }

          const sql = fs.readFileSync('sql_encoded.txt', 'utf8');
          const url = `https://${account}.snowflakecomputing.com/api/v2/statements/`;
          const body = {
            statement: sql,
            database: process.env.SNOW_DATABASE,
            schema: process.env.SNOW_SCHEMA,
            warehouse: process.env.SNOW_WAREHOUSE,
            timeout: 0
          };

          (async () => {
            console.log('Submitting SQL to', url);
            const r = await fetch(url, {
              method: 'POST',
              headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
              body: JSON.stringify(body)
            });

            console.log('POST status', r.status);
            let j;
            try {
              j = await r.json();
            } catch (e) {
              console.error('Failed to parse JSON response, status:', r.status);
              process.exit(12);
            }
            console.log(JSON.stringify(j, null, 2));

            if (!j.id) {
              console.error('No id returned');
              process.exit(2);
            }

            const id = j.id;
            const statusUrl = url + id;
            for (let i = 0; i < 30; i++) {
              await new Promise(r => setTimeout(r, 1000));
              const s = await fetch(statusUrl, { headers: { 'Authorization': 'Bearer ' + token }});
              const sj = await s.json();
              console.log('Poll', i, 'status', s.status);
              console.log(JSON.stringify(sj, null, 2));
              if (sj.status && (sj.status.state === 'SUCCESS' || sj.status.state === 'FAILED')) {
                if (sj.status.state === 'SUCCESS') {
                  console.log('SUCCESS');
                  process.exit(0);
                } else {
                  console.error('FAILED');
                  process.exit(3);
                }
              }
            }
            console.error('Timeout waiting for statement');
            process.exit(4);
          })();
          EOF
